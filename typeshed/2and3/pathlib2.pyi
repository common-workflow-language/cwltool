# Stubs for pathlib2 (Python 3.5)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from collections import Sequence
from typing import Any, Optional

class _Flavour:
    join: Any = ...
    def __init__(self) -> None: ...
    def parse_parts(self, parts): ...
    def join_parsed_parts(self, drv, root, parts, drv2, root2, parts2): ...

class _WindowsFlavour(_Flavour):
    sep: str = ...
    altsep: str = ...
    has_drv: bool = ...
    pathmod: Any = ...
    is_supported: Any = ...
    drive_letters: Any = ...
    ext_namespace_prefix: str = ...
    reserved_names: Any = ...
    def splitroot(self, part, sep: Any = ...): ...
    def casefold(self, s): ...
    def casefold_parts(self, parts): ...
    def resolve(self, path, strict: bool = ...): ...
    def is_reserved(self, parts): ...
    def make_uri(self, path): ...
    def gethomedir(self, username): ...

class _PosixFlavour(_Flavour):
    sep: str = ...
    altsep: str = ...
    has_drv: bool = ...
    pathmod: Any = ...
    is_supported: Any = ...
    def splitroot(self, part, sep: Any = ...): ...
    def casefold(self, s): ...
    def casefold_parts(self, parts): ...
    def resolve(self, path, strict: bool = ...): ...
    def is_reserved(self, parts): ...
    def make_uri(self, path): ...
    def gethomedir(self, username): ...

class _Accessor: ...

class _NormalAccessor(_Accessor):
    stat: Any = ...
    lstat: Any = ...
    open: Any = ...
    listdir: Any = ...
    scandir: Any = ...
    chmod: Any = ...
    def lchmod(self, pathobj, mode): ...
    mkdir: Any = ...
    unlink: Any = ...
    rmdir: Any = ...
    rename: Any = ...
    replace: Any = ...
    def symlink(a, b, target_is_directory): ...
    @staticmethod
    def symlink(a, b, target_is_directory): ...
    utime: Any = ...
    def readlink(self, path): ...

class _Selector:
    child_parts: Any = ...
    successor: Any = ...
    dironly: bool = ...
    def __init__(self, child_parts) -> None: ...
    def select_from(self, parent_path): ...

class _TerminatingSelector: ...

class _PreciseSelector(_Selector):
    name: Any = ...
    def __init__(self, name, child_parts) -> None: ...

class _WildcardSelector(_Selector):
    pat: Any = ...
    def __init__(self, pat, child_parts) -> None: ...

class _RecursiveWildcardSelector(_Selector):
    def __init__(self, pat, child_parts) -> None: ...

class _PathParents(Sequence):
    def __init__(self, path) -> None: ...
    def __len__(self): ...
    def __getitem__(self, idx): ...

class PurePath:
    def __new__(cls, *args): ...
    def __reduce__(self): ...
    def __fspath__(self): ...
    def as_posix(self): ...
    def __bytes__(self): ...
    def as_uri(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __hash__(self): ...
    def __lt__(self, other): ...
    def __le__(self, other): ...
    def __gt__(self, other): ...
    def __ge__(self, other): ...
    drive: Any = ...
    root: Any = ...
    @property
    def anchor(self): ...
    @property
    def name(self): ...
    @property
    def suffix(self): ...
    @property
    def suffixes(self): ...
    @property
    def stem(self): ...
    def with_name(self, name): ...
    def with_suffix(self, suffix): ...
    def relative_to(self, *other): ...
    @property
    def parts(self): ...
    def joinpath(self, *args): ...
    def __truediv__(self, key): ...
    def __rtruediv__(self, key): ...
    __div__: Any = ...
    __rdiv__: Any = ...
    @property
    def parent(self): ...
    @property
    def parents(self): ...
    def is_absolute(self): ...
    def is_reserved(self): ...
    def match(self, path_pattern): ...

class PurePosixPath(PurePath): ...
class PureWindowsPath(PurePath): ...

class Path(PurePath):
    def __new__(cls, *args, **kwargs): ...
    def __enter__(self): ...
    def __exit__(self, t, v, tb): ...
    @classmethod
    def cwd(cls): ...
    @classmethod
    def home(cls): ...
    def samefile(self, other_path): ...
    def iterdir(self): ...
    def glob(self, pattern): ...
    def rglob(self, pattern): ...
    def absolute(self): ...
    def resolve(self, strict: bool = ...): ...
    def stat(self): ...
    def owner(self): ...
    def group(self): ...
    def open(self, mode: str = ..., buffering: int = ..., encoding: Optional[Any] = ..., errors: Optional[Any] = ..., newline: Optional[Any] = ...): ...
    def read_bytes(self): ...
    def read_text(self, encoding: Optional[Any] = ..., errors: Optional[Any] = ...): ...
    def write_bytes(self, data): ...
    def write_text(self, data, encoding: Optional[Any] = ..., errors: Optional[Any] = ...): ...
    def touch(self, mode: int = ..., exist_ok: bool = ...): ...
    def mkdir(self, mode: int = ..., parents: bool = ..., exist_ok: bool = ...): ...
    def chmod(self, mode): ...
    def lchmod(self, mode): ...
    def unlink(self): ...
    def rmdir(self): ...
    def lstat(self): ...
    def rename(self, target): ...
    def replace(self, target): ...
    def symlink_to(self, target, target_is_directory: bool = ...): ...
    def exists(self) -> bool: ...
    def is_dir(self): ...
    def is_file(self): ...
    def is_symlink(self): ...
    def is_block_device(self): ...
    def is_char_device(self): ...
    def is_fifo(self): ...
    def is_socket(self): ...
    def expanduser(self): ...

class PosixPath(Path, PurePosixPath): ...

class WindowsPath(Path, PureWindowsPath):
    def owner(self): ...
    def group(self): ...
